.. _onegate_usage:

=======================
Application Monitoring
=======================

OneGate allows Virtual Machine guests to pull and push service and vm information from OpenNebula. Users and administrators can use it to gather metrics, detect problems in their applications, and trigger OneFlow elasticity rules.

For Virtual Machines that are part of a Multi-VM Application (Service), they can also retrieve the Service information directly from OneGate.

OneGate Workflow Explained
==========================

OneGate is a server that listens to http connections from the Virtual Machines. OpenNebula assigns an individual token to each VM instance, and Applications running inside the VM use this token to send monitoring metrics to OneGate. This token is generated using VM information and signed with the user TOKEN_PASSWORD. This password can be changed updating the user template, but tokens from existing vms will not work anymore.

When OneGate checks the VM ID and the token sent, the new information is placed inside the VM's user template section. This means that the application metrics are visible from the command line, Sunstone, or the APIs.

OneGate Usage
=============

First, the cloud administrator must configure and start the :ref:`OneGate server <onegate_configure>`.

Setup the VM Template
---------------------

Your VM Template must set the CONTEXT/TOKEN attribute to ``yes``.

.. code::

    CPU     = "0.5"
    MEMORY  = "128"
     
    DISK = [
      IMAGE_ID = "0" ]
    NIC = [
      NETWORK_ID = "0" ]
     
    CONTEXT = [
      TOKEN = "YES" ]

When this Template is instantiated, OpenNebula will automatically add the ONEGATE_ENDPOINT context variable, and a token.txt will be placed in the context cdrom. This token.txt file is only accessible from inside the VM.

.. code::

    ...
     
    CONTEXT=[
      DISK_ID="1",
      ONEGATE_ENDPOINT="http://192.168.0.1:5030",
      TARGET="hdb",
      TOKEN="YES" ]

OneGate API
-----------

OneGate provides a REST API. To use this API you will need to get some data from the CONTEXT file.

The contextualization cdrom should contain the ``context.sh`` and ``token.txt`` files.

.. code::

    # mkdir /mnt/context
    # mount /dev/hdb /mnt/context
    # cd /mnt/context
    # ls
    context.sh  token.txt
    # cat context.sh
    # Context variables generated by OpenNebula
    DISK_ID='1'
    ONEGATE_ENDPOINT='http://192.168.0.1:5030'
    VMID='0'
    TARGET='hdb'
    TOKEN='yes'

    # cat token.txt
    yCxieDUS7kra7Vn9ILA0+g==

With that data, you can obtain the headers required for all the ONEGATE API methods:

* **Headers**:

    * ``X-ONEGATE-TOKEN: token.txt contents``
    * ``X-ONEGATE-VMID: <vmid>``

OneGate supports these actions:

* ``GET ${ONEGATE_ENDPOINT}/vm``: To request information about the Virtual Machine. The information is returned in JSON format and is ready for public cloud usage:

    .. code::

        $ curl -X "GET" "${ONEGATE_ENDPOINT}/vm" \
            --header "X-ONEGATE-TOKEN: `cat token.txt`" \
            --header "X-ONEGATE-VMID: $VMID"
        {
            "VM": {
                "ID": ...,
                "NAME": ...,
                "TEMPLATE": {
                    "NIC": [
                        {
                            "IP": ...,
                            "IP6_LINK": ...,
                            "MAC": ...,
                            "NETWORK": ...,
                        },
                        // more nics ...
                    ]
                },
                "USER_TEMPLATE": {
                    "ROLE_NAME": ...,
                    "SERVICE_ID": ...,
                    // more user template attributes
                }
            }
        }

* ``PUT ${ONEGATE_ENDPOINT}/vm``: To add information to the VM template:

    .. code::

        $ curl -X "PUT" "${ONEGATE_ENDPOINT}/vm" \
            --header "X-ONEGATE-TOKEN: `cat token.txt`" \
            --header "X-ONEGATE-VMID: $VMID" \
            -d "APP_LOAD = 9.7"

    The new metric is stored in the user template section of the VM:

    .. code::

        $ onevm show 0
        ...
        USER TEMPLATE
        APP_LOAD="9.7"


* ``GET ${ONEGATE_ENDPOINT}/service``: To request information about the Virtual Machine. The information is returned in JSON format and is ready for public cloud usage:

    .. code::

        $ curl -X "GET" "${ONEGATE_ENDPOINT}/service" \
            --header "X-ONEGATE-TOKEN: `cat token.txt`" \
            --header "X-ONEGATE-VMID: $VMID"

        {
            "SERVICE": {
                "id": ...,
                "name": ...,
                "roles": [
                    {
                        "name": ...,
                        "cardinality": ...,
                        "state": ...,
                        "nodes": [
                            {
                                "deploy_id": ...,
                                "running": true|false,
                                "vm_info": {
                                    // VM template as return by GET /VM
                                }

                            },
                            // more nodes ...
                        ]
                    },
                    // more roles ...
                ]
            }
        }

* ``GET ${ONEGATE_ENDPOINT}``: returns information endpoints:

    .. code::

        $ curl -X "GET" "${ONEGATE_ENDPOINT}/service" \
            --header "X-ONEGATE-TOKEN: `cat token.txt`" \
            --header "X-ONEGATE-VMID: $VMID"

        {
            "vm_info": "http://<onegate_endpoint>/vm",
            "service_info": "http://<onegate_endpoint>/service"
        }

By pushing data ``PUT /VM`` from one VM and pulling the service data from another VM ``GET /service``, nodes that are part of a OneFlow service can pass values from one to another.

Sample Script
=============

.. code::

    #!/bin/bash
     
    # -------------------------------------------------------------------------- #
    # Copyright 2002-2013, OpenNebula Project (OpenNebula.org), C12G Labs        #
    #                                                                            #
    # Licensed under the Apache License, Version 2.0 (the "License"); you may    #
    # not use this file except in compliance with the License. You may obtain    #
    # a copy of the License at                                                   #
    #                                                                            #
    # http://www.apache.org/licenses/LICENSE-2.0                                 #
    #                                                                            #
    # Unless required by applicable law or agreed to in writing, software        #
    # distributed under the License is distributed on an "AS IS" BASIS,          #
    # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
    # See the License for the specific language governing permissions and        #
    # limitations under the License.                                             #
    #--------------------------------------------------------------------------- #
     
    ################################################################################
    # Initialization
    ################################################################################
     
    ERROR=0
     
    if [ -z $ONEGATE_TOKEN ]; then
        echo "ONEGATE_TOKEN env variable must point to the token.txt file"
        ERROR=1
    fi
     
    if [ -z $ONEGATE_ENDPOINT ]; then
        echo "ONEGATE_ENDPOINT env variable must be set"
        ERROR=1
    fi
     
    if [ $ERROR = 1 ]; then
        exit -1
    fi
     
    TMP_DIR=`mktemp -d`
    echo "" > $TMP_DIR/metrics
     
    ################################################################################
    # Memory metrics
    ################################################################################
     
    MEM_TOTAL=`grep MemTotal: /proc/meminfo | awk '{print $2}'`
    MEM_FREE=`grep MemFree: /proc/meminfo | awk '{print $2}'`
    MEM_USED=$(($MEM_TOTAL-$MEM_FREE))
     
    MEM_USED_PERC="0"
     
    if ! [ -z $MEM_TOTAL ] && [ $MEM_TOTAL -gt 0 ]; then
        MEM_USED_PERC=`echo "$MEM_USED $MEM_TOTAL" | \
            awk '{ printf "%.2f", 100 * $1 / $2 }'`
    fi
     
    SWAP_TOTAL=`grep SwapTotal: /proc/meminfo | awk '{print $2}'`
    SWAP_FREE=`grep SwapFree: /proc/meminfo | awk '{print $2}'`
    SWAP_USED=$(($SWAP_TOTAL - $SWAP_FREE))
     
    SWAP_USED_PERC="0"
     
    if ! [ -z $SWAP_TOTAL ] && [ $SWAP_TOTAL -gt 0 ]; then
        SWAP_USED_PERC=`echo "$SWAP_USED $SWAP_TOTAL" | \
            awk '{ printf "%.2f", 100 * $1 / $2 }'`
    fi
     
     
    #echo "MEM_TOTAL = $MEM_TOTAL" >> $TMP_DIR/metrics
    #echo "MEM_FREE = $MEM_FREE" >> $TMP_DIR/metrics
    #echo "MEM_USED = $MEM_USED" >> $TMP_DIR/metrics
    echo "MEM_USED_PERC = $MEM_USED_PERC" >> $TMP_DIR/metrics
     
    #echo "SWAP_TOTAL = $SWAP_TOTAL" >> $TMP_DIR/metrics
    #echo "SWAP_FREE = $SWAP_FREE" >> $TMP_DIR/metrics
    #echo "SWAP_USED = $SWAP_USED" >> $TMP_DIR/metrics
    echo "SWAP_USED_PERC = $SWAP_USED_PERC" >> $TMP_DIR/metrics
     
    ################################################################################
    # Disk metrics
    ################################################################################
     
    /bin/df -k -P | grep '^/dev' > $TMP_DIR/df
     
    cat $TMP_DIR/df | while read line; do
        NAME=`echo $line | awk '{print $1}' | awk -F '/' '{print $NF}'`
     
        DISK_TOTAL=`echo $line | awk '{print $2}'`
        DISK_USED=`echo $line | awk '{print $3}'`
        DISK_FREE=`echo $line | awk '{print $4}'`
     
        DISK_USED_PERC="0"
     
        if ! [ -z $DISK_TOTAL ] && [ $DISK_TOTAL -gt 0 ]; then
            DISK_USED_PERC=`echo "$DISK_USED $DISK_TOTAL" | \
                awk '{ printf "%.2f", 100 * $1 / $2 }'`
        fi
     
        #echo "DISK_TOTAL_$NAME = $DISK_TOTAL" >> $TMP_DIR/metrics
        #echo "DISK_FREE_$NAME = $DISK_FREE" >> $TMP_DIR/metrics
        #echo "DISK_USED_$NAME = $DISK_USED" >> $TMP_DIR/metrics
        echo "DISK_USED_PERC_$NAME = $DISK_USED_PERC" >> $TMP_DIR/metrics
    done
     
    ################################################################################
    # PUT command
    ################################################################################
     
    VMID=(source /mnt/context.sh; echo $VMID)

    curl -X "PUT" $ONEGATE_ENDPOINT/vm \
        --header "X-ONEGATE-TOKEN: `cat $ONEGATE_TOKEN`" \
        --header "X-ONEGATE-VMID: $VMID" \
        --data-binary @$TMP_DIR/metrics

